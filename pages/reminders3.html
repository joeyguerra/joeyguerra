<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reminders App - MVC with KVO</title>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module" id="HotReloader">
        import { HotReloader } from '/js/HotReloader.mjs'
        const hotReloader = new HotReloader(window, io('/hot-reload'))
    </script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
        }

        aside {
            width: 300px;
            background: #f2f2f7;
            border-right: 1px solid #d1d1d6;
            padding: 10px;
            overflow-y: auto;
        }

        main {
            flex: 1;
            padding: 20px;
            background: #ffffff;
            overflow-y: auto;
        }

        .group {
            margin-bottom: 8px;
            padding: 10px;
            background: #ffffff;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #1c1c1e;
        }

        .input-inline {
            width: 100%;
            margin-top: 4px;
            padding: 8px;
            font-size: 14px;
            border: none;
            background-color: transparent;
        }

        .tree ul {
            list-style: none;
            padding-left: 15px;
        }

        .tree li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            min-height: 40px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .tree li:hover {
            background-color: #e5e5ea;
        }

        .tree li.selected {
            background-color: #d1d1d6; /* macOS blue color */
            color: #1c1c1e;
            font-weight: bold;
        }
        
        .tree li.selected.active {
            background-color: #0071e3; /* macOS gray color */
            color: white;
        }

        .completed {
            text-decoration: line-through;
            color: #8e8e93;
        }

        button {
            background: none;
            border: none;
            cursor: pointer;
            color: #ff3b30;
            font-size: 14px;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .drag-ghost {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            background: transparent;
            list-style: none;
            list-style-position: inside;
        }

        li.phantom-slot {
            height: 1px;
            line-height: 1px;
            min-height: 1px;
            background: #e6f0ff;
            margin: 0;
            padding: 0;
            list-style: none;
            position: relative;
            display: block;
            width: 100%;
            border-bottom: solid 1px #007aff;
        }

        li.phantom-slot::before {
            content: 'o';
            display: inline-block;
            color: #007aff;
            margin-left: -9px;
        }

        .phantom-slot {
            height: 40px;
            background: #e6f0ff;
            margin: 4px 0;
            border-radius: 4px;
        }

        .tree li span {
            outline: none; /* Remove outline when editing */
            padding: 2px 4px;
            border-radius: 3px;
        }

        .tree li span[contenteditable="true"] {
            background-color: white;
            border: 1px solid #007aff;
            min-width: 50px;
            display: inline-block;
        }
    </style>
</head>

<body>
    <aside>
        <input id="newGroupInput" class="input-inline" placeholder="New group name" />
        <div id="groupContainer" class="tree"></div>
    </aside>
    <main>
        <div id="mainContent"></div>
    </main>

    <script type="module">
        // Save to localStorage
        function saveToLocalStorage() {
            localStorage.setItem('remindersAppData', JSON.stringify({
                groups: appState.groups,
                selectedListTitle: appState.selectedList ? appState.selectedList.title : null,
                selectedGroupIndex: appState.lastActiveGroupIndex
            }))
        }

        // Load from localStorage
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('remindersAppData')
            if (!savedData) return false
            
            try {
                const parsedData = JSON.parse(savedData)
                
                // Reconstruct groups with their proper class instances
                appState.groups = parsedData.groups.map(groupData => {
                    const group = new Group(groupData.name)
                    
                    // Reconstruct lists
                    group.lists = groupData.lists.map(listData => {
                        const list = new ReminderList(listData.title)
                        
                        // Reconstruct sections with KVOModel
                        list.sections = listData.sections.map(sectionData => {
                            const section = new KVOModel({ 
                                name: sectionData.data.name,
                                reminders: []
                            })
                            
                            // Reconstruct reminders
                            section.data.reminders = sectionData.data.reminders.map(reminderData => {
                                const reminder = new Reminder(reminderData.text)
                                reminder.completed = reminderData.completed
                                reminder.createdAt = new Date(reminderData.createdAt)
                                reminder.completedAt = reminderData.completedAt ? new Date(reminderData.completedAt) : null
                                return reminder
                            })
                            
                            return section
                        })
                        
                        return list
                    })
                    
                    return group
                })
                
                // Find the selected list if it exists
                if (parsedData.selectedListTitle) {
                    for (const group of appState.groups) {
                        for (const list of group.lists) {
                            if (list.title === parsedData.selectedListTitle) {
                                appState.selectedList = list
                                break
                            }
                        }
                        if (appState.selectedList) break
                    }
                }
                
                // Restore last active group index
                appState.lastActiveGroupIndex = parsedData.selectedGroupIndex
                
                return true
            } catch (error) {
                console.error('Error loading data from localStorage:', error)
                return false
            }
        }

        class KVOModel {
            constructor(data = {}) {
                this.data = data
                this.observers = {}
            }

            get(key) {
                return this.data[key]
            }

            set(key, value) {
                const oldValue = this.data[key]
                this.data[key] = value
                if (this.observers[key]) {
                    this.observers[key].forEach(cb => cb(value, oldValue))
                }
            }

            observe(key, cb) {
                if (!this.observers[key]) this.observers[key] = []
                this.observers[key].push(cb)
            }
        }

        class Reminder {
            constructor(text) {
                this.text = text
                this.completed = false
                this.createdAt = new Date()
                this.completedAt = null
            }

            toggle() {
                this.completed = !this.completed
                this.completedAt = this.completed ? new Date() : null
            }
        }

        class ReminderList {
            constructor(title) {
                this.title = title
                this.sections = []
            }

            addSection(name) {
                const section = new KVOModel({ name, reminders: [] })
                this.sections.push(section)
                return section
            }
        }

        class Group {
            constructor(name) {
                this.name = name
                this.lists = []
            }

            addList(name) {
                const list = new ReminderList(name)
                this.lists.push(list)
                return list
            }
        }

        const appState = {
            groups: [],
            selectedList: null,
            lastActiveGroupIndex: null // Track the last active group
        }

        let isDraggingListItem = false
        let globalDragData = {
            currentGroup: null,
            dragIndex: null
        }

        const groupContainer = document.getElementById('groupContainer')
        const mainContent = document.getElementById('mainContent')

        function renderSidebar() {
            groupContainer.innerHTML = ''
            appState.groups.forEach((group, groupIndex) => {
                const groupEl = document.createElement('div')
                groupEl.className = 'group'
                groupEl.draggable = true
                groupEl.dataset.index = groupIndex

                groupEl.addEventListener('dragstart', (e) => {
                    if (isDraggingListItem) {
                        e.preventDefault()
                        return
                    }
                    e.dataTransfer.setData('text/plain', groupIndex)
                })

                groupEl.addEventListener('dragover', (e) => {
                    if (isDraggingListItem) return
                    if (e.target !== groupEl) return
                    e.preventDefault()
                    groupEl.style.opacity = 0.5
                })

                groupEl.addEventListener('dragleave', () => {
                    if (isDraggingListItem) return
                    groupEl.style.opacity = 1.0
                })

                groupEl.addEventListener('drop', (e) => {
                    if (isDraggingListItem) return
                    if (e.target !== groupEl) return
                    e.preventDefault()
                    groupEl.style.opacity = 1.0
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'))
                    const toIndex = parseInt(groupEl.dataset.index)
                    if (fromIndex !== toIndex) {
                        const moved = appState.groups.splice(fromIndex, 1)[0]
                        appState.groups.splice(toIndex, 0, moved)
                        renderSidebar()
                    }
                })

                const header = document.createElement('div')
                header.className = 'group-header'
                header.innerHTML = `<strong>${group.name}</strong>`
                const delBtn = document.createElement('button')
                delBtn.textContent = 'ðŸ—‘'
                delBtn.onclick = () => {
                    appState.groups.splice(groupIndex, 1)
                    renderSidebar()
                    saveToLocalStorage() // Save after deleting a group
                }
                header.appendChild(delBtn)

                const listInput = document.createElement('input')
                listInput.className = 'input-inline'
                listInput.placeholder = 'New list name'
                listInput.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        // Track which group is currently active
                        appState.lastActiveGroupIndex = groupIndex
                        
                        group.addList(listInput.value)
                        listInput.value = ''
                        renderSidebar()
                        saveToLocalStorage() // Save after adding a list
                    }
                }
                
                // Mark this input when it receives focus
                listInput.onfocus = () => {
                    appState.lastActiveGroupIndex = groupIndex
                }

                const listEl = document.createElement('ul')
                group.lists.forEach((list, listIndex) => {
                    const li = document.createElement('li')
                    li.draggable = true
                    li.dataset.index = listIndex

                    let ghostEl = null
                    let dragIndex = null
                    let currentGroup = null
                    let isDragging = false
                    let startX, startY

                    li.addEventListener('mousedown', (e) => {
                        // Only proceed if it's a left click (button 0)
                        if (e.button !== 0) return
                        
                        e.preventDefault()
                        startX = e.pageX
                        startY = e.pageY
                        
                        const move = (e) => {
                            // Only start dragging if mouse has moved significantly
                            if (!isDragging) {
                                const deltaX = Math.abs(e.pageX - startX)
                                const deltaY = Math.abs(e.pageY - startY)
                                
                                // If moved more than 3px, start dragging
                                if (deltaX > 3 || deltaY > 3) {
                                    isDragging = true
                                    isDraggingListItem = true
                                    
                                    // Store drag data globally for access during drop
                                    globalDragData.dragIndex = listIndex
                                    globalDragData.currentGroup = group
                                    
                                    // Clone element for drag ghost
                                    ghostEl = li.cloneNode(true)
                                    ghostEl.classList.add('drag-ghost')
                                    ghostEl.style.left = `${e.pageX}px`
                                    ghostEl.style.top = `${e.pageY}px`
                                    document.body.appendChild(ghostEl)
                                    
                                    // Add visual feedback
                                    li.classList.add('dragging')
                                }
                            }
                            
                            if (isDragging && ghostEl) {
                                ghostEl.style.left = `${e.pageX}px`
                                ghostEl.style.top = `${e.pageY}px`
                                
                                // Update phantom slot position based on current mouse position
                                document.querySelectorAll('.phantom-slot').forEach(el => el.remove())
                                
                                // Find closest list item to cursor for drop indication
                                const allListItems = document.querySelectorAll('.tree li')
                                let closestItem = null
                                let closestDistance = Infinity
                                
                                allListItems.forEach(item => {
                                    const rect = item.getBoundingClientRect()
                                    const itemMiddleY = rect.top + rect.height / 2
                                    const distance = Math.abs(e.clientY - itemMiddleY)
                                    
                                    if (distance < closestDistance) {
                                        closestDistance = distance
                                        closestItem = item
                                    }
                                })
                                
                                if (closestItem) {
                                    const slot = document.createElement('li')
                                    slot.className = 'phantom-slot'
                                    slot.dataset.dropTarget = 'true'
                                    
                                    // Position slot above or below the closest item
                                    const rect = closestItem.getBoundingClientRect()
                                    const insertBefore = e.clientY < (rect.top + rect.height / 2)
                                    
                                    if (insertBefore) {
                                        closestItem.parentNode.insertBefore(slot, closestItem)
                                    } else {
                                        closestItem.parentNode.insertBefore(slot, closestItem.nextSibling)
                                    }
                                }
                            }
                        }

                        const up = (e) => {
                            document.removeEventListener('mousemove', move)
                            document.removeEventListener('mouseup', up)
                            
                            if (isDragging) {
                                // Handle the drop
                                const slots = document.querySelectorAll('.phantom-slot')
                                if (slots.length > 0 && globalDragData.currentGroup && globalDragData.dragIndex !== null) {
                                    const slot = slots[0]
                                    const listItems = Array.from(slot.parentNode.children)
                                    const toIndex = listItems.indexOf(slot)
                                    
                                    // Create a deep copy of the list
                                    const originalGroup = globalDragData.currentGroup
                                    const originalList = originalGroup.lists[globalDragData.dragIndex]
                                    const listCopy = new ReminderList(originalList.title)
                                    
                                    // Deep copy sections and reminders
                                    originalList.sections.forEach(section => {
                                        const newSection = listCopy.addSection(section.get('name'))
                                        section.get('reminders').forEach(reminder => {
                                            const newReminder = new Reminder(reminder.text)
                                            newReminder.completed = reminder.completed
                                            newReminder.createdAt = new Date(reminder.createdAt)
                                            newReminder.completedAt = reminder.completedAt ? new Date(reminder.completedAt) : null
                                            newSection.get('reminders').push(newReminder)
                                        })
                                    })
                                    
                                    // Remove original from data model
                                    originalGroup.lists.splice(globalDragData.dragIndex, 1)
                                    
                                    // Get the target group
                                    const closestGroupEl = slot.closest('.group')
                                    const targetGroupIndex = parseInt(closestGroupEl.dataset.index, 10)
                                    const targetGroup = appState.groups[targetGroupIndex]
                                    
                                    // Insert copy at destination
                                    const actualToIndex = Math.min(toIndex, targetGroup.lists.length)
                                    targetGroup.lists.splice(actualToIndex, 0, listCopy)
                                    
                                    // Update selected list reference if needed
                                    if (appState.selectedList === originalList) {
                                        appState.selectedList = listCopy
                                    }
                                    
                                    // Clean up dragging artifacts
                                    if (ghostEl) ghostEl.remove()
                                    document.querySelectorAll('.phantom-slot').forEach(el => el.remove())
                                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'))
                                    
                                    // Update UI immediately without animation
                                    renderSidebar()
                                    renderMain()
                                    saveToLocalStorage()
                                } else {
                                    // No valid drop target, clean up
                                    if (ghostEl) ghostEl.remove()
                                    document.querySelectorAll('.phantom-slot').forEach(el => el.remove())
                                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'))
                                }
                                
                                isDraggingListItem = false
                                isDragging = false
                            } else {
                                // This was a click, not a drag - select the list
                                appState.selectedList = list
                                renderMain()
                                renderSidebar()
                                saveToLocalStorage()
                            }
                        }

                        document.addEventListener('mousemove', move)
                        document.addEventListener('mouseup', up)
                    })

                    li.addEventListener('dragover', (e) => {
                        e.preventDefault()
                        e.stopPropagation()

                        document.querySelectorAll('.phantom-slot').forEach(el => el.remove())

                        const slot = document.createElement('li')
                        slot.className = 'phantom-slot'
                        slot.dataset.dropTarget = 'true'
                        li.parentNode.insertBefore(slot, li)
                    })

                    li.addEventListener('drop', (e) => {
                        e.preventDefault()
                        e.stopPropagation()

                        const slots = document.querySelectorAll('.phantom-slot')
                        if (slots.length > 0 && currentGroup && dragIndex !== null) {
                            const slot = slots[0]
                            const toIndex = Array.from(slot.parentNode.children).indexOf(slot)
                            
                            // Create a proper deep copy of the list
                            const originalList = currentGroup.lists[dragIndex]
                            const listCopy = new ReminderList(originalList.title)
                            
                            // Deep copy all sections and reminders
                            originalList.sections.forEach(section => {
                                const newSection = listCopy.addSection(section.get('name'))
                                section.get('reminders').forEach(reminder => {
                                    const newReminder = new Reminder(reminder.text)
                                    newReminder.completed = reminder.completed
                                    newReminder.createdAt = new Date(reminder.createdAt)
                                    newReminder.completedAt = reminder.completedAt ? new Date(reminder.completedAt) : null
                                    newSection.get('reminders').push(newReminder)
                                })
                            })
                            
                            // Remove the original
                            currentGroup.lists.splice(dragIndex, 1)
                            
                            // Insert the copy at the new position
                            currentGroup.lists.splice(toIndex, 0, listCopy)
                            
                            // Update the selected list reference if it was the moved list
                            if (appState.selectedList === originalList) {
                                appState.selectedList = listCopy
                            }
                            
                            // Reset drag state
                            isDraggingListItem = false
                            isDragging = false
                            
                            renderSidebar()
                            renderMain()
                        }

                        if (ghostEl) ghostEl.remove()
                        document.querySelectorAll('.phantom-slot').forEach(el => el.remove())
                    })

                    li.addEventListener('mouseup', (e) => {
                        if(!isDragging) return
                        e.preventDefault()
                        e.stopPropagation()

                        const slots = document.querySelectorAll('.phantom-slot')
                        if (slots.length > 0 && currentGroup && dragIndex !== null) {
                            const slot = slots[0]
                            const toIndex = Array.from(slot.parentNode.children).indexOf(slot)
                            
                            // Create a proper deep copy of the list
                            const originalList = currentGroup.lists[dragIndex]
                            const listCopy = new ReminderList(originalList.title)
                            
                            // Deep copy all sections and reminders
                            originalList.sections.forEach(section => {
                                const newSection = listCopy.addSection(section.get('name'))
                                section.get('reminders').forEach(reminder => {
                                    const newReminder = new Reminder(reminder.text)
                                    newReminder.completed = reminder.completed
                                    newReminder.createdAt = new Date(reminder.createdAt)
                                    newReminder.completedAt = reminder.completedAt ? new Date(reminder.completedAt) : null
                                    newSection.get('reminders').push(newReminder)
                                })
                            })
                            
                            // Remove the original
                            currentGroup.lists.splice(dragIndex, 1)
                            
                            // Insert the copy at the new position
                            currentGroup.lists.splice(toIndex, 0, listCopy)
                            
                            // Update the selected list reference if it was the moved list
                            if (appState.selectedList === originalList) {
                                appState.selectedList = listCopy
                            }
                            
                            renderSidebar()
                            renderMain()
                        }

                        if (ghostEl) ghostEl.remove()
                        document.querySelectorAll('.phantom-slot').forEach(el => el.remove())
                    })

                    const span = document.createElement('span')
                    span.textContent = list.title
                    span.style.cursor = 'pointer'
                    
                    // Add click handler for selection
                    span.onclick = (e) => {
                        appState.selectedList = list
                        
                        // Remove active class from all list items first
                        document.querySelectorAll('.tree li').forEach(item => {
                            item.classList.remove('active')
                        })
                        
                        // Mark this list item as active (clicked into)
                        li.classList.add('active')
                        
                        renderMain()
                        renderSidebar()
                        saveToLocalStorage() // Save when changing selected list
                    }

                    const deleteBtn = document.createElement('button')
                    deleteBtn.textContent = 'ðŸ—‘'
                    deleteBtn.onclick = () => {
                        group.lists.splice(listIndex, 1)
                        renderSidebar()
                        saveToLocalStorage() // Save after deleting a list
                    }

                    li.appendChild(span)
                    li.appendChild(deleteBtn)
                    listEl.appendChild(li)
                })
                groupEl.appendChild(header)
                groupEl.appendChild(listInput)
                groupEl.appendChild(listEl)
                groupContainer.appendChild(groupEl)
                
                // Store the input reference if this is the active group
                if (appState.lastActiveGroupIndex === groupIndex) {
                    // Focus will be applied after all groups are rendered
                    setTimeout(() => listInput.focus(), 0)
                }
            })
            
            // If no group was previously active or that group is gone, focus the last one
            if (appState.lastActiveGroupIndex === null || appState.lastActiveGroupIndex >= appState.groups.length) {
                if (appState.groups.length > 0) {
                    const lastGroupEl = groupContainer.lastChild
                    const lastInput = lastGroupEl.querySelector('input.input-inline')
                    setTimeout(() => lastInput.focus(), 0)
                }
            }
        }

        function renderMain() {
            mainContent.innerHTML = ''
            const list = appState.selectedList
            if (!list) return

            const title = document.createElement('h2')
            title.textContent = list.title
            mainContent.appendChild(title)

            const addSectionInput = document.createElement('input')
            addSectionInput.placeholder = 'New section title'
            addSectionInput.className = 'input-inline'
            addSectionInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    list.addSection(addSectionInput.value)
                    addSectionInput.value = ''
                    renderMain()
                    saveToLocalStorage() // Save when adding a section
                }
            }

            mainContent.appendChild(addSectionInput)

            list.sections.forEach((section, sectionIndex) => {
                const sectionDiv = document.createElement('div')
                sectionDiv.className = 'section'

                const nameInput = document.createElement('input')
                nameInput.value = section.get('name')
                nameInput.className = 'input-inline'
                nameInput.onchange = () => {
                    section.set('name', nameInput.value)
                    saveToLocalStorage() // Save when changing section name
                }
                sectionDiv.appendChild(nameInput)

                const reminderInput = document.createElement('input')
                reminderInput.placeholder = 'New reminder'
                reminderInput.className = 'input-inline'
                reminderInput.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        const reminder = new Reminder(reminderInput.value)
                        section.get('reminders').push(reminder)
                        reminderInput.value = ''
                        renderMain()
                        saveToLocalStorage() // Save when adding a reminder
                    }
                }
                sectionDiv.appendChild(reminderInput)

                const ul = document.createElement('ul')
                section.get('reminders').forEach((r, rIndex) => {
                    const li = document.createElement('li')
                    li.className = 'reminder'

                    const label = document.createElement('label')
                    const checkbox = document.createElement('input')
                    checkbox.type = 'checkbox'
                    checkbox.checked = r.completed
                    checkbox.onchange = () => {
                        r.toggle()
                        renderMain()
                        saveToLocalStorage() // Save when toggling a reminder
                    }

                    const span = document.createElement('span')
                    span.textContent = r.text
                    if (r.completed) span.classList.add('completed')

                    const meta = document.createElement('div')
                    meta.style.fontSize = '12px'
                    meta.style.color = '#666'
                    meta.innerHTML = `Created: ${r.createdAt.toLocaleString()}<br>` +
                        (r.completedAt ? `Completed: ${r.completedAt.toLocaleString()}` : '')

                    label.appendChild(checkbox)
                    label.appendChild(span)
                    li.appendChild(label)
                    li.appendChild(meta)
                    ul.appendChild(li)
                })

                sectionDiv.appendChild(ul)
                mainContent.appendChild(sectionDiv)
            })
        }

        document.getElementById('newGroupInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const name = e.target.value.trim()
                if (name) {
                    appState.groups.push(new Group(name))
                    e.target.value = ''
                    renderSidebar()
                    saveToLocalStorage() // Save after adding a new group
                }
            }
        })

        // Initialize app by loading data from localStorage
        function initApp() {
            // Try to load from localStorage first
            if (!loadFromLocalStorage()) {
                // If nothing in localStorage, create sample data
                const personalGroup = new Group('Personal')
                const workGroup = new Group('Work')
                
                const todoList = personalGroup.addList('To Do')
                const section = todoList.addSection('Today')
                section.get('reminders').push(new Reminder('Call Mom'))
                section.get('reminders').push(new Reminder('Buy groceries'))
                
                const workTodo = workGroup.addList('Work Tasks')
                const workSection = workTodo.addSection('This Week')
                workSection.get('reminders').push(new Reminder('Finish project proposal'))
                workSection.get('reminders').push(new Reminder('Schedule meeting'))
                
                appState.groups.push(personalGroup)
                appState.groups.push(workGroup)
                appState.selectedList = todoList
            }
            
            renderSidebar()
            renderMain()
        }

        // Initialize the app when page loads
        window.addEventListener('DOMContentLoaded', initApp)
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Cone Tracker</title>
  <style>
    html {
      transition: background 0.3s ease, color 0.3s ease;
    }
  
    body, main, .task, .question, .status-options label, .task-status-group label {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    .dark-mode span[style*='--tag-bg'] {
      background-color: #444;
      color: #eee;
    }
    .cone::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: radial-gradient(circle at center, rgba(255, 0, 0, var(--heatmap-opacity, 0.15)), transparent 60%);
      pointer-events: none;
      z-index: 0;
    }
  
    .task.drag-over {
      border-top: 3px solid #007bff;
      margin-top: 0.5rem;
      transition: margin 0.2s ease;
    }
    .task.dragging {
      opacity: 0.5;
    }
    .task::before {
      content: 'â ¿';
      margin-right: 0.5rem;
      cursor: grab;
      display: inline-block;
    }

    .task[data-status='done']::before {
      content: '';
      display: none;
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #f9f9f9;
      color: #333;
    }

    header {
      background: #222;
      color: white;
      padding: 1rem;
      text-align: center;
    }

    main {
      max-width: 800px;
      margin: 2rem auto;
      padding: 1rem;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    form {
      display: grid;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    input, textarea, select {
      padding: 0.5rem;
      font-size: 1rem;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 5px;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    .task, .question {
      border-left: 4px solid #ccc;
      padding: 1rem;
      margin-bottom: 1rem;
      border-radius: 5px;
      background: #f1f1f1;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .task[data-status="todo"] { border-color: orange }
    .task[data-status="in-progress"] { border-color: dodgerblue }
    .task[data-status="done"] { border-color: green }
    .question.resolved { opacity: 0.6; text-decoration: line-through }

    .cone {
      width: 100%;
      height: 200px;
      background: linear-gradient(to right, transparent, #ddd, transparent);
      position: relative;
      margin-bottom: 2rem;
      overflow: hidden;
    }

    .dot {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .dot.todo { background: orange }
    .dot.in-progress { background: dodgerblue }
    .dot.done { background: green }

    .dot.question {
      width: 2px;
      height: 2px;
      border-radius: 0;
      transform: rotate(45deg);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: rotate(45deg) scale(1); opacity: 1; }
      50% { transform: rotate(45deg) scale(1.15); opacity: 0.5; }
      50% { transform: rotate(45deg) scale(1.4); opacity: 0.5; }
    }

    #parking-lot {
      margin-top: 3rem;
    }

    .task-section {
      margin-bottom: 2rem;
    }

    .task-section h3 {
      margin-bottom: 1rem;
      border-bottom: 2px solid #ccc;
    }
    .status-options, .task-status-group {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }

  .status-options label, .task-status-group label {
    padding: 0.4rem 1rem;
    border: 1px solid #ccc;
    border-radius: 999px;
    background-color: #f0f0f0;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
  }

  .status-options input[type="radio"], .task-status-group input[type="radio"] {
    display: none;
  }

  .status-options input[type="radio"]:checked + label,
  .task-status-group input[type="radio"]:checked + label {
    background-color: #007bff;
    color: white;
    border-color: #007bff;
  }
  .status-options, .task-status-group {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }

  .status-options label, .task-status-group label {
    padding: 0.4rem 1rem;
    border: 1px solid #ccc;
    border-radius: 999px;
    background-color: #f0f0f0;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s ease;
  }

  .status-options input[type="radio"], .task-status-group input[type="radio"] {
    display: none;
  }

  .status-options input[value="todo"]:checked + label,
  .task-status-group input[value="todo"]:checked + label {
    background-color: orange;
    color: white;
    border-color: orange;
  }

  .status-options input[value="in-progress"]:checked + label,
  .task-status-group input[value="in-progress"]:checked + label {
    background-color: dodgerblue;
    color: white;
    border-color: dodgerblue;
  }

  .status-options input[value="done"]:checked + label,
  .task-status-group input[value="done"]:checked + label {
    background-color: green;
    color: white;
    border-color: green;
  }
  @media (max-width: 600px) {
    .status-options,
    .task-status-group {
      flex-direction: column;
      gap: 0.25rem;
    }

    .task {
      flex-direction: column;
      align-items: flex-start;
    }

    .task h3,
    .task p {
      width: 100%;
    }
  }
  .dark-mode body {
    background: #0d0d0d;
    color: #f0f0f0;
  }

  .dark-mode main {
    background: #1a1a1a;
    box-shadow: 0 2px 10px rgba(255, 255, 255, 0.1);
  }

  .dark-mode .task, .dark-mode .question {
    background: #262626;
    border-left-color: #999;
  }

  .dark-mode .status-options label, .dark-mode .task-status-group label {
    background-color: #333;
    border-color: #888;
    color: #f0f0f0;
  }

  .dark-mode .status-options input[type="radio"]:checked + label,
  .dark-mode .task-status-group input[type="radio"]:checked + label {
    color: white;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background: #121212;
      color: #eee;
    }

    main {
      background: #1e1e1e;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
    }

    .task, .question {
      background: #2a2a2a;
      border-left-color: #444;
    }

    .status-options label, .task-status-group label {
      background-color: #333;
      border-color: #555;
      color: #eee;
    }

    .status-options input[type="radio"]:checked + label,
    .task-status-group input[type="radio"]:checked + label {
      color: white;
    }
  }
  .task[data-status='done'] {
    opacity: 0.6;
    pointer-events: none;
  }
</style>
</head>
<body>
  <header>
    <h1>Project Cone Tracker</h1>
      <div style="position: absolute; top: 1rem; right: 1rem;">
      <label style="color: white;">
        <input type="checkbox" id="dark-toggle"> ðŸŒ™ Dark Mode
      </label>
    </div>
  </header>
  <main>
    <section id="legend" style="margin-bottom: 2rem;">
      <h2>Legend</h2>
      <ul style="list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 1rem;">
        <li><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:orange;margin-right:0.5rem;"></span> To Do</li>
        <li><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:dodgerblue;margin-right:0.5rem;"></span> In Progress</li>
        <li><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:green;margin-right:0.5rem;"></span> Done</li>
        <li><span style="display:inline-block;width:12px;height:12px;background:#999;transform:rotate(45deg);margin-right:0.5rem;"></span> Unresolved Question</li>
      </ul>
    </section>
    <div class="cone" id="cone"></div>
    <form id="task-form">
      <input type="text" id="tags" placeholder="Comma-separated tags (e.g. design, backend)" />
      <input type="text" id="title" placeholder="Task title" required>
      <textarea id="note" placeholder="Task notes"></textarea>
      <div id="status" class="status-options">
        <label><input type="radio" name="status" value="todo" checked> To Do</label>
        <label><input type="radio" name="status" value="in-progress"> In Progress</label>
        <label><input type="radio" name="status" value="done"> Done</label>
      </div>
      <button type="submit">Add Task</button>
    </form>
    
    <button id="toggle-archive" style="margin-bottom: 1rem;">Show Archived</button>
    <div id="task-list"></div>

    <section id="parking-lot">
      <h2>Parking Lot (Questions & Unknowns)</h2>
      <form id="question-form">
        <input type="text" id="question-input" placeholder="Enter question or unknown..." required>
        <button type="submit">Add Question</button>
      </form>
      <div id="question-list"></div>
    </section>
  </main>
  <script>
    class Task {
      constructor(title, note, status, tags = [], created = new Date().toISOString()) {
        this.title = title
        this.note = note
        this.status = status
        this.tags = tags
        this.created = created
      }

      render(index, updateCallback, editCallback) {
        const div = document.createElement('div')
        div.className = 'task'
        const isDraggable = this.status === 'todo'
        div.draggable = isDraggable
        div.draggable = (this.status === 'todo')
        div.dataset.index = index
        div.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/plain', index)
          div.classList.add('dragging')
        })
        div.addEventListener('dragend', () => div.classList.remove('dragging'))
        div.dataset.status = this.status

        const titleEl = document.createElement('h3')
        titleEl.contentEditable = true
        titleEl.textContent = this.title
        titleEl.addEventListener('blur', () => editCallback(index, 'title', titleEl.textContent))

        const noteEl = document.createElement('p')
        noteEl.contentEditable = true
        noteEl.textContent = this.note
        noteEl.addEventListener('blur', () => editCallback(index, 'note', noteEl.textContent))

        const tagList = document.createElement('div')
        tagList.style.marginTop = '0.5rem'
        const timestamp = document.createElement('div')
        timestamp.textContent = new Date(this.created).toLocaleString()
        timestamp.style.fontSize = '0.75rem'
        timestamp.style.color = '#666'
        timestamp.style.marginTop = '0.25rem'
        this.tags.forEach(tag => {
          const span = document.createElement('span')
          span.textContent = tag
          span.style.background = 'var(--tag-bg, #eee)'
          span.style.borderRadius = '999px'
          span.style.padding = '0.2rem 0.5rem'
          span.style.marginRight = '0.25rem'
          span.style.fontSize = '0.8rem'
          tagList.appendChild(span)
        })
        tagList.appendChild(timestamp)
        tagList.addEventListener('click', e => editCallback(index, 'note', noteEl.textContent))

        const label = document.createElement('label')
        label.textContent = 'Status: '
        const statusOptions = ['todo', 'in-progress', 'done']
        const container = document.createElement('div')
        statusOptions.forEach(option => {
          const radio = document.createElement('input')
          radio.type = 'radio'
          radio.name = `status-${index}`
          radio.value = option
          radio.id = `status-${index}-${option}`
          if (this.status === option) radio.checked = true
          radio.addEventListener('change', e => {
            this.status = e.target.value
            updateCallback(index, this.status)
          })
          const labelEl = document.createElement('label')
          labelEl.htmlFor = radio.id
          const icons = { 'todo': 'ðŸ“', 'in-progress': 'ðŸš§', 'done': 'âœ…' }
          labelEl.textContent = `${icons[option]} ${option.replace('-', ' ')}`
          container.appendChild(radio)
          container.appendChild(labelEl)
        })
        container.classList.add('task-status-group')
        label.appendChild(container)

        div.appendChild(titleEl)
        div.appendChild(noteEl)
        div.appendChild(tagList)
        div.appendChild(label)

        return div
      }
    }

    const randomColor = () => `hsl(${Math.floor(Math.random()*360)}, 70%, 60%)`

    class ProjectCone {
      constructor() {
        this.tasks = []
        this.questions = []
        this.form = document.getElementById('task-form')
        this.list = document.getElementById('task-list')
        this.cone = document.getElementById('cone')
        this.questionForm = document.getElementById('question-form')
        this.questionList = document.getElementById('question-list')
        this.showArchived = false
        this.load()
        this.init()
        document.getElementById('toggle-archive').addEventListener('click', () => {
          this.showArchived = !this.showArchived
          this.renderTasks()
        })
      }

      init() {
        this.form.addEventListener('submit', e => {
          e.preventDefault()
          this.addTask()
        })

        this.questionForm.addEventListener('submit', e => {
          e.preventDefault()
          this.addQuestion()
        })
      }

      addTask() {
        const title = document.getElementById('title').value
        const note = document.getElementById('note').value
        const status = document.querySelector('input[name="status"]:checked').value
        const tags = document.getElementById('tags').value.split(',').map(t => t.trim()).filter(Boolean)
        const task = new Task(title, note, status, tags)
        this.tasks.push(task)
        this.save()
        this.renderTasks()
        this.renderQuestions()
        this.renderCone()
        this.form.reset()
        document.getElementById('tags').value = ''
      }

      addQuestion() {
        const input = document.getElementById('question-input')
        const question = input.value.trim()
        if (question.length > 0) {
          this.questions.push({ text: question, resolved: false, created: new Date().toISOString() })
          this.save()
          this.renderQuestions()
          this.renderCone()
          input.value = ''
        }
      }

      toggleResolved(index) {
        this.questions[index].resolved = !this.questions[index].resolved
        this.save()
        this.renderQuestions()
        this.renderCone()
      }

      deleteQuestion(index) {
        this.questions.splice(index, 1)
        this.save()
        this.renderQuestions()
        this.renderCone()
      }

      updateStatus(index, newStatus) {
        this.tasks[index].status = newStatus
        this.save()
        this.renderTasks()
        this.renderCone()
      }

      editTask(index, field, value) {
        this.tasks[index][field] = value
        this.save()
        this.renderCone()
      }

      renderTasks() {
        this.list.innerHTML = ''
                const grouped = {
          'in-progress': [],
          'todo': [],
          'done': []
        }
        this.tasks.forEach((t, i) => {
          const rendered = t.render(i, this.updateStatus.bind(this), this.editTask.bind(this))
          grouped[t.status].push(rendered)
                  })
        const showArchived = this.showArchived ?? false
        document.getElementById('toggle-archive').textContent = showArchived ? 'Hide Archived' : 'Show Archived'
        for (const status of ['in-progress', 'todo', 'done']) {
          if (grouped[status].length > 0 && (status !== 'done' || showArchived)) {
            const section = document.createElement('div')
            section.className = 'task-section'
            const title = document.createElement('h3')
            title.textContent = status === 'in-progress' ? 'In Progress' : status === 'todo' ? 'To Do' : 'Done'
            section.appendChild(title)
            grouped[status].forEach(taskEl => section.appendChild(taskEl))
            this.list.appendChild(section)
            section.addEventListener('dragover', e => {
            e.preventDefault()
            const taskEl = e.target.closest('.task')
            document.querySelectorAll('.task').forEach(el => el.classList.remove('drag-over'))
                if (taskEl) taskEl.classList.add('drag-over')
            })
            section.addEventListener('drop', e => {
                document.querySelectorAll('.task').forEach(el => el.classList.remove('drag-over'))
                e.preventDefault()
                const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'))
                const draggedTask = this.tasks[draggedIndex]
                const targetTaskEl = e.target.closest('.task')
                const targetIndex = parseInt(targetTaskEl?.dataset.index)
                if (draggedTask?.status === 'todo' && !isNaN(targetIndex) && draggedIndex !== targetIndex && this.tasks[targetIndex].status === 'todo') {
                    const [moved] = this.tasks.splice(draggedIndex, 1)
                    this.tasks.splice(targetIndex, 0, moved)
                    this.save()
                    this.renderTasks()
                    this.renderCone()
                }
            })
          }
        }
      }

      renderQuestions() {
        this.questionList.innerHTML = ''
        const sortedQuestions = [...this.questions].sort((a, b) => a.resolved - b.resolved)
        sortedQuestions.forEach((q, i) => {
          const div = document.createElement('div')
          div.className = 'question' + (q.resolved ? ' resolved' : '')
          const span = document.createElement('span')
          span.textContent = q.text + ' â€” ' + new Date(q.created).toLocaleString()
          const resolveBtn = document.createElement('button')
          resolveBtn.textContent = q.resolved ? 'Unresolve' : 'Resolve'
          resolveBtn.addEventListener('click', () => this.toggleResolved(this.questions.indexOf(q)))
          const deleteBtn = document.createElement('button')
          deleteBtn.textContent = 'Delete'
          deleteBtn.addEventListener('click', () => this.deleteQuestion(this.questions.indexOf(q)))
          div.appendChild(span)
          div.appendChild(resolveBtn)
          div.appendChild(deleteBtn)
          this.questionList.appendChild(div)
        })
      }

      renderCone() {
        this.cone.innerHTML = ''
        const taskOrderMap = { 'todo': 0, 'in-progress': 1, 'done': 2 }
        const taskGroups = [[], [], []]
        this.tasks.forEach(task => taskGroups[taskOrderMap[task.status]].push(task))

        const total = this.tasks.length
        let index = 0
        taskGroups.forEach((group, groupIndex) => {
          group.forEach(task => {
            const dot = document.createElement('div')
            dot.className = `dot ${task.status}`
            const x = (index + 1) / (total + 1)
            const y = (groupIndex + 1) / 4
            dot.style.left = `${x * 100}%`
            dot.style.top = `${y * 100}%`
            this.cone.appendChild(dot)
            index++
          })
        })

        this.questions.forEach(q => {
          if (!q.resolved) {
            const dot = document.createElement('div')
            dot.className = 'dot question'
            dot.style.left = `${Math.random() * 100}%`
            dot.style.top = `${Math.random() * 100}%`
            dot.style.background = randomColor()
            this.cone.appendChild(dot)
          }
        })
      }

      save() {
        localStorage.setItem('project-tasks', JSON.stringify(this.tasks))
        localStorage.setItem('project-questions', JSON.stringify(this.questions))
      }

      load() {
        const savedTasks = localStorage.getItem('project-tasks')
        if (savedTasks) {
          const parsed = JSON.parse(savedTasks)
          this.tasks = parsed.map(t => new Task(t.title, t.note, t.status, t.tags || [], t.created))
        }
        const savedQuestions = localStorage.getItem('project-questions')
        if (savedQuestions) {
          this.questions = JSON.parse(savedQuestions).map(q => ({ ...q, created: q.created || new Date().toISOString() }))
        }
        this.renderTasks()
        this.renderQuestions()
        this.renderCone()
      }
    }

    new ProjectCone()
    const toggle = document.getElementById('dark-toggle')
    toggle.addEventListener('change', () => {
      if (toggle.checked) {
        document.documentElement.classList.add('dark-mode')
        localStorage.setItem('theme', 'dark')
      } else {
        document.documentElement.classList.remove('dark-mode')
        localStorage.setItem('theme', 'light')
      }
    })

    if (localStorage.getItem('theme') === 'dark') {
      toggle.checked = true
      document.documentElement.classList.add('dark-mode')
    }
  </script>
</body>
</html>
